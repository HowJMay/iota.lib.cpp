<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iota.lib.cpp: IOTA Javascript Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iota.lib.cpp
   </div>
   <div id="projectbrief">IOTA C++ Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">IOTA Javascript Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://raw.githubusercontent.com/iotaledger/iota.lib.js/master/LICENSE"></a> <a href="https://travis-ci.org/iotaledger/iota.lib.js"></a> <a href="https://david-dm.org/iotaledger/iota.lib.js"></a> <a href="https://david-dm.org/iotaledger/iota.lib.js?type=dev"></a> <a href="https://nodesecurity.io/orgs/iota-foundation/projects/7c0214b5-e36a-4178-92bc-164c536cfd6c"></a></p>
<p>This is the official Javascript library for the IOTA Core. It implements both the <a href="https://iota.readme.io/">official API</a>, as well as newly proposed functionality (such as signing, bundles, utilities and conversion).</p>
<p>It should be noted that the Javascript Library as it stands right now is an <b>early beta release</b>. As such, there might be some unexpected results. Please join the community (see links below) and post <a href="https://github.com/iotaledger/iota.lib.js/issues">issues on here</a>, to ensure that the developers of the library can improve it.</p>
<blockquote class="doxtable">
<p><b>Join the Discussion</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>If you want to get involved in the community, need help with getting setup, have any issues related with the library or just want to discuss Blockchain, Distributed Ledgers and IoT with other people, feel free to join our Slack. <a href="http://slack.iota.org/">Slack</a> You can also ask questions on our dedicated forum at: <a href="https://forum.iota.org/">IOTA Forum</a>. </p>
</blockquote>
<h2>Installation</h2>
<h3>Node.js</h3>
<div class="fragment"><div class="line">npm install iota.lib.js</div></div><!-- fragment --><h3>Bower</h3>
<div class="fragment"><div class="line">bower install iota.lib.js</div></div><!-- fragment --><p>Once you've built the dist with gulp, you can either use <code>iota.js</code> or the minified version <code>iota.min.js</code> in the browser. </p><hr/>
<h1>Documentation</h1>
<p>It should be noted that this is a temporary home for the official documentation. We are currently transitioning to a new developer hub, where we will have a dedicated website for the API documentation with concrete examples. The below documentation should be sufficient in enabling you to get started in the meantime.</p>
<h2>Getting Started</h2>
<p>After you've successfully installed the library, it is fairly easy to get started by simply launching a new instance of the IOTA object with an optional settings object. When instantiating the object you have the option to decide the API provider that is used to send the requests to and you can also connect directly to the Sandbox environment.</p>
<p>The optional settings object can have the following values:</p>
<ol type="1">
<li>**<code>host</code>**: <code>String</code> Host you want to connect to. Can be DNS, IPv4 or IPv6. Defaults to <code>localhost</code></li>
<li>**<code>port</code>**: <code>Int</code> port of the host you want to connect to. Defaults to 14265.</li>
<li>**<code>provider</code>**: <code>String</code> If you don't provide host and port, you can supply the full provider value to connect to</li>
<li>**<code>sandbox</code>**: <code>Bool</code> Optional value to determine if your provider is the IOTA Sandbox or not.</li>
</ol>
<p>You can either supply the remote node directly via the <code>provider</code> option, or individually with <code>host</code> and <code>port</code>, as can be seen in the example below:</p>
<div class="fragment"><div class="line">// Create IOTA instance with host and port as provider</div><div class="line">var iota = new IOTA({</div><div class="line">    &#39;host&#39;: &#39;http://localhost&#39;,</div><div class="line">    &#39;port&#39;: 14265</div><div class="line">});</div><div class="line"></div><div class="line">// Create IOTA instance directly with provider</div><div class="line">var iota = new IOTA({</div><div class="line">    &#39;provider&#39;: &#39;http://localhost:14265&#39;</div><div class="line">});</div><div class="line"></div><div class="line">// now you can start using all of the functions</div><div class="line">iota.api.getNodeInfo();</div><div class="line"></div><div class="line">// you can also get the version</div><div class="line">iota.version</div></div><!-- fragment --><p>Overall, there are currently four subclasses that are accessible from the IOTA object:</p><ul>
<li>**<code>api</code>**: Core API functionality for interacting with the IOTA core.</li>
<li>**<code>utils</code>**: Utility related functions for conversions, validation and so on</li>
<li>**<code>multisig</code>**: Functions for creating and signing multi-signature addresses and transactions.</li>
<li>**<code>valid</code>**: Validator functions that can help with determining whether the inputs or results that you get are valid.</li>
</ul>
<p>You also have access to the <code>version</code> of the library</p><ul>
<li>**<code>version</code>**: Current version of the library</li>
</ul>
<p>In the future new IOTA Core modules (such as Flash, MAM) and all IXI related functionality will be available.</p>
<h2>How to use the Library</h2>
<p>It should be noted that most API calls are done asynchronously. What this means is that you have to utilize callbacks in order to catch the response successfully. We will add support for sync API calls, as well as event listeners in future versions.</p>
<p>Here is a simple example of how to access the <code>getNodeInfo</code> function:</p>
<div class="fragment"><div class="line">iota.api.getNodeInfo(function(error, success) {</div><div class="line">    if (error) {</div><div class="line">        console.error(error);</div><div class="line">    } else {</div><div class="line">        console.log(success);</div><div class="line">    }</div><div class="line">})</div></div><!-- fragment --> <hr/>
<h2>API Table of Contents</h2>
<ul>
<li><b><a href="#api">api</a></b><ul>
<li><b><a href="#standard-api">Standard API</a></b></li>
<li><b><a href="#gettransactionsobjects">getTransactionsObjects</a></b></li>
<li><b><a href="#findtransactionobjects">findTransactionObjects</a></b></li>
<li><b><a href="#getlatestinclusion">getLatestInclusion</a></b></li>
<li><b><a href="#broadcastandstore">broadcastAndStore</a></b></li>
<li><b><a href="#getnewaddress">getNewAddress</a></b></li>
<li><b><a href="#getinputs">getInputs</a></b></li>
<li><b><a href="#preparetransfers">prepareTransfers</a></b></li>
<li><b><a href="#sendtrytes">sendTrytes</a></b></li>
<li><b><a href="#sendtransfer">sendTransfer</a></b></li>
<li><b><a href="#replaybundle">replayBundle</a></b></li>
<li><b><a href="#broadcastbundle">broadcastBundle</a></b></li>
<li><b><a href="#getbundle">getBundle</a></b></li>
<li><b><a href="#gettransfers">getTransfers</a></b></li>
<li><b><a href="#getaccountdata">getAccountData</a></b></li>
<li><b><a href="#isreattachable">isReattachable</a></b></li>
</ul>
</li>
<li><b><a href="#iota.utils">utils</a></b><ul>
<li><b><a href="#convertunits">convertUnits</a></b></li>
<li><b><a href="#addchecksum">addChecksum</a></b></li>
<li><b><a href="#nochecksum">noChecksum</a></b></li>
<li><b><a href="#isvalidchecksum">isValidChecksum</a></b></li>
<li><b><a href="#transactionobject">transactionObject</a></b></li>
<li><b><a href="#transactiontrytes">transactionTrytes</a></b></li>
<li><b><a href="#categorizetransfers">categorizeTransfers</a></b></li>
<li><b><a href="#totrytes">toTrytes</a></b></li>
<li><b><a href="#fromtrytes">fromTrytes</a></b></li>
<li><b><a href="#extractjson">extractJson</a></b></li>
<li><b><a href="#validatesignatures">validateSignatures</a></b></li>
<li><b><a href="#isbundle">isBundle</a></b></li>
</ul>
</li>
<li><b><a href="#iota.multisig">multisig</a></b><ul>
<li><b><a href="#getkey">getKey</a></b></li>
<li><b><a href="#getdigest">getDigest</a></b></li>
<li><b><a href="#Address">Address</a></b></li>
<li><b><a href="#Address.absorb">Address.absorb</a></b></li>
<li><b><a href="#Address.finalize">Address.finalize</a></b></li>
<li><b><a href="#validateaddress">validateAddress</a></b></li>
<li><b><a href="#initiatetransfer">initiateTransfer</a></b></li>
<li><b><a href="#addsignature">addSignature</a></b></li>
</ul>
</li>
<li><b><a href="#iota.valid">valid</a></b><ul>
<li><b><a href="#isaddress">isAddress</a></b></li>
<li><b><a href="#istrytes">isTrytes</a></b></li>
<li><b><a href="#isvalue">isValue</a></b></li>
<li><b><a href="#isnum">isNum</a></b></li>
<li><b><a href="#ishash">isHash</a></b></li>
<li><b><a href="#istransfersarray">isTransfersArray</a></b></li>
<li><b><a href="#isarrayofhashes">isArrayOfHashes</a></b></li>
<li><b><a href="#isarrayoftrytes">isArrayOfTrytes</a></b></li>
<li><b><a href="#isarrayofattachedtrytes">isArrayOfAttachedTrytes</a></b></li>
<li><b><a href="#isarrayoftxobjects">isArrayOfTxObjects</a></b></li>
<li><b><a href="#isinputs">isInputs</a></b></li>
<li><b><a href="#isstring">isString</a></b></li>
<li><b><a href="#isarray">isArray</a></b></li>
<li><b><a href="#isobject">isObject</a></b></li>
<li><b><a href="#isuri">isUri</a></b> <hr/>
</li>
</ul>
</li>
</ul>
<h2><code>iota.api</code></h2>
<h3><code>Standard API</code></h3>
<p>This Javascript library has implemented all of the core API calls that are made available by the current <a href="https://github.com/iotaledger/iri">IOTA Reference Implementation</a>. For the full documentation of all the Standard API calls, please refer to the official documentation: <a href="https://iota.readme.io/">official API</a>.</p>
<p>You can simply use any of the available options from the <code>api</code> object then. For example, if you want to use the <code>getTips</code> function, you would simply do it as such:</p>
<div class="fragment"><div class="line">iota.api.getTips(function(error, success) {</div><div class="line">    // do stuff here</div><div class="line">})</div></div><!-- fragment --> <hr/>
<h3><code>getTransactionsObjects</code></h3>
<p>Wrapper function for <code>getTrytes</code> and the Utility function <code>transactionObjects</code>. This function basically returns the entire transaction objects for a list of transaction hashes.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.getTransactionsObjects(hashes, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>hashes</code>**: <code>Array</code> List of transaction hashes</li>
<li>**<code>callback</code>**: <code>Function</code> callback.</li>
</ol>
<h4>Return Value</h4>
<ol type="1">
<li>**<code>Array</code>** - list of all the transaction objects from the corresponding hashes. <hr/>
</li>
</ol>
<h3><code>findTransactionObjects</code></h3>
<p>Wrapper function for <code>findTransactions</code>, <code>getTrytes</code> and the Utility function <code>transactionObjects</code>. This function basically returns the entire transaction objects for a list of key values which you would usually use for <code>findTransactions</code>. Acceptable key values are:</p>
<ul>
<li>*<code>bundles</code>*: List of bundle hashes</li>
<li>*<code>addresses</code>*: List of addresses</li>
<li>*<code>tags</code>*: List of transaction tags (27 trytes length)</li>
<li>*<code>approvees</code>*: List of approvees</li>
</ul>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.findTransactionObjects(searchValues, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>searchValues</code>**: <code>Object</code> List of transaction hashes. e.g. `{'hashes': ['ABCD']}<code></code></li>
<li><code>**</code>callback<code>**:</code>Function` callback.</li>
</ol>
<h4>Return Value</h4>
<ol type="1">
<li>**<code>Array</code>** - list of all the transaction objects from the corresponding hashes. <hr/>
</li>
</ol>
<h3><code>getLatestInclusion</code></h3>
<p>Wrapper function for <code>getNodeInfo</code> and <code>getInclusionStates</code>. It simply takes the most recent solid milestone as returned by getNodeInfo, and uses it to get the inclusion states of a list of transaction hashes.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.getLatestInclusion(hashes, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>hashes</code>**: <code>Array</code> List of transaction hashes</li>
<li>**<code>callback</code>**: <code>Function</code> callback.</li>
</ol>
<h4>Return Value</h4>
<ol type="1">
<li>**<code>Array</code>** - list of all the inclusion states of the transaction hashes <hr/>
</li>
</ol>
<h3><code>broadcastAndStore</code></h3>
<p>Wrapper function for <code>broadcastTransactions</code> and <code>storeTransactions</code>.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.broadcastAndStore(trytes, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>trytes</code>**: <code>Array</code> List of transaction trytes to be broadcast and stored. Has to be trytes that were returned from <code>attachToTangle</code></li>
<li>**<code>callback</code>**: <code>Function</code> callback.</li>
</ol>
<h4>Return Value</h4>
<p>**<code>Object</code>** - empty object. </p><hr/>
<h3><code>getNewAddress</code></h3>
<p>Generates a new address from a seed and returns the address. This is either done deterministically, or by providing the index of the new address to be generated. When generating an address, you have the option to choose different <code>security</code> levels for your private keys. A different security level with the same key index, means that you will get a different address obviously (as such, you could argue that single seed has 3 different accounts, depending on the security level chosen).</p>
<p>In total, there are 3 different security options available to choose from:</p>
<table class="doxtable">
<tr>
<th>Input </th><th>Security Level </th><th>Security  </th></tr>
<tr>
<td>1 </td><td>Low </td><td>81-trits </td></tr>
<tr>
<td>2 </td><td>Medium </td><td>162-trits </td></tr>
<tr>
<td>3 </td><td>High </td><td>243-trits </td></tr>
</table>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.getNewAddress(seed [, options], callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>**: <code>String</code> tryte-encoded seed. It should be noted that this seed is not transferred</li>
<li>**<code>options</code>**: <code>Object</code> which is optional:<ul>
<li>**<code>index</code>**: <code>Int</code> If the index is provided, the generation of the address is not deterministic.</li>
<li>**<code>checksum</code>**: <code>Bool</code> Adds 9-tryte address checksum</li>
<li>**<code>total</code>**: <code>Int</code> Total number of addresses to generate.</li>
<li>**<code>security</code>**: <code>Int</code> Security level to be used for the private key / address. Can be 1, 2 or 3</li>
<li>**<code>returnAll</code>**: <code>Bool</code> If true, it returns all addresses which were deterministically generated (until findTransactions returns null)</li>
</ul>
</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback.</li>
</ol>
<h4>Returns</h4>
<p>**<code>String | Array</code>** - returns either a string, or an array of strings. </p><hr/>
<h3><code>getInputs</code></h3>
<p>Gets all possible inputs of a seed and returns them with the total balance. This is either done deterministically (by genearating all addresses until <code>findTransactions</code> returns null for a corresponding address), or by providing a key range to use for searching through.</p>
<p>You can also define the minimum <code>threshold</code> that is required. This means that if you provide the <code>threshold</code> value, you can specify that the inputs should only be returned if their collective balance is above the threshold value.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.getInputs(seed, [, options], callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>**: <code>String</code> tryte-encoded seed. It should be noted that this seed is not transferred</li>
<li>**<code>options</code>**: <code>Object</code> which is optional:<ul>
<li>**<code>start</code>**: <code>int</code> Starting key index</li>
<li>**<code>end</code>**: <code>int</code> Ending key index</li>
<li>**<code>security</code>**: <code>Int</code> Security level to be used for the private key / address. Can be 1, 2 or 3</li>
<li>**<code>threshold</code>**: <code>int</code> Minimum threshold of accumulated balances from the inputs that is requested</li>
</ul>
</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback.</li>
</ol>
<h4>Return Value</h4>
<ol type="1">
<li>**<code>Object</code>** - an object with the following keys:<ul>
<li>**<code>inputs</code>** <code>Array</code> - list of inputs objects consisting of <code>address</code>, <code>balance</code> and <code>keyIndex</code></li>
<li>**<code>totalBalance</code>** <code>int</code> - aggregated balance of all inputs</li>
</ul>
</li>
</ol>
<hr/>
<h3><code>prepareTransfers</code></h3>
<p>Main purpose of this function is to get an array of transfer objects as input, and then prepare the transfer by <b>generating the correct bundle</b>, as well as <b>choosing and signing the inputs</b> if necessary (if it's a value transfer). The output of this function is an array of the raw transaction data (trytes).</p>
<p>You can provide multiple transfer objects, which means that your prepared bundle will have multiple outputs to the same, or different recipients. As single transfer object takes the values of: <code>address</code>, <code>value</code>, <code>message</code>, <code>tag</code>. The message and tag values are required to be tryte-encoded. If you do not supply a message or a tag, the library will automatically enter empty ones for you. As such the only required fields in each transfers object are <code>address</code> and <code>value</code>.</p>
<p>If you provide an address with a checksum, this function will automatically validate the address for you with the Utils function <code>isValidChecksum</code>.</p>
<p>For the options, you can provide a list of <code>inputs</code>, that will be used for signing the transfer's inputs. It should be noted that these inputs (an array of objects) should have the provided 'security', <code>keyIndex</code> and <code>address</code> values: </p><div class="fragment"><div class="line">var inputs = [{</div><div class="line">    &#39;keyIndex&#39;: //VALUE,</div><div class="line">    &#39;address&#39;: //VALUE,</div><div class="line">    &#39;security&#39;: //VALUE</div><div class="line">}]</div></div><!-- fragment --><p>The library validates these inputs then and ensures that you have sufficient balance. When defining these inputs, you can also provide multiple inputs on different security levels. The library will correctly sign these inputs using your seed and the corresponding private keys. Here is an example using security level 3 and 2 for a transfer:</p>
<div class="fragment"><div class="line">iota.api.prepareTransfers(seed,</div><div class="line">    [{</div><div class="line">        &#39;address&#39;: &#39;SSEWOZSDXOVIURQRBTBDLQXWIXOLEUXHYBGAVASVPZ9HBTYJJEWBR9PDTGMXZGKPTGSUDW9QLFPJHTIEQZNXDGNRJE&#39;,</div><div class="line">        &#39;value&#39;: 10000</div><div class="line">    }], {</div><div class="line">    &#39;inputs&#39;: [</div><div class="line">        {</div><div class="line">            address: &#39;XB9IBINADVMP9K9FEIIR9AYEOFUU9DP9EBCKOTPSDVSNRRNVSJOPTFUHSKSLPDJLEHUBOVEIOJFPDCZS9&#39;,</div><div class="line">            balance: 1500,</div><div class="line">            keyIndex: 0,</div><div class="line">            security: 3</div><div class="line">        }, {</div><div class="line">            address: &#39;W9AZFNWZZZNTAQIOOGYZHKYJHSVMALVTWJSSZDDRVEIXXWPNWEALONZLPQPTCDZRZLHNIHSUKZRSZAZ9W&#39;,</div><div class="line">            balance: 8500,</div><div class="line">            keyIndex: 7,</div><div class="line">            security: 2</div><div class="line">        }</div><div class="line">    ], function(e, s) {</div><div class="line"></div><div class="line"></div><div class="line">        console.log(e,s);</div><div class="line">})</div></div><!-- fragment --><p>The <code>address</code> option can be used to define the address to which a remainder balance (if that is the case), will be sent to. So if all your inputs have a combined balance of 2000, and your spending 1800 of them, 200 of your tokens will be sent to that remainder address. If you do not supply the <code>address</code>, the library will simply generate a new one from your seed (taking <code>security</code> into account, or using the standard security value of <code>2</code> (medium)).</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.prepareTransfers(seed, transfersArray [, options], callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>**: <code>String</code> tryte-encoded seed. It should be noted that this seed is not transferred</li>
<li>**<code>transfersArray</code>**: <code>Array</code> of transfer objects:<ul>
<li>**<code>address</code>**: <code>String</code> 81-tryte encoded address of recipient</li>
<li>**<code>value</code>**: <code>Int</code> value to be transferred.</li>
<li>**<code>message</code>**: <code>String</code> tryte-encoded message to be included in the bundle.</li>
<li>**<code>tag</code>**: <code>String</code> Tryte-encoded tag. Maximum value is 27 trytes.</li>
</ul>
</li>
<li>**<code>options</code>**: <code>Object</code> which is optional:<ul>
<li>**<code>inputs</code>**: <code>Array</code> List of inputs used for funding the transfer</li>
<li>**<code>address</code>**: <code>String</code> if defined, this address will be used for sending the remainder value (of the inputs) to.</li>
<li>**<code>security</code>**: <code>Int</code> Security level to be used for the private key / addresses. This is for inputs and generating of the remainder address in case you did not specify it. Can be 1, 2 or 3</li>
</ul>
</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback.</li>
</ol>
<h4>Return Value</h4>
<p><code>Array</code> - an array that contains the trytes of the new bundle. </p><hr/>
<h3><code>sendTrytes</code></h3>
<p>Wrapper function that does <code>attachToTangle</code> and finally, it broadcasts and stores the transactions.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.sendTrytes(trytes, depth, minWeightMagnitude, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>trytes</code>** <code>Array</code> trytes</li>
<li>**<code>depth</code>** <code>Int</code> depth value that determines how far to go for tip selection</li>
<li>**<code>minWeightMagnitude</code>** <code>Int</code> minWeightMagnitude</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback.</li>
</ol>
<h4>Returns</h4>
<p><code>Array</code> - returns an array of the transfer (transaction objects). </p><hr/>
<h3><code>sendTransfer</code></h3>
<p>Wrapper function that basically does <code>prepareTransfers</code>, as well as <code>attachToTangle</code> and finally, it broadcasts and stores the transactions locally.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.sendTransfer(seed, depth, minWeightMagnitude, transfers [, options], callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>** <code>String</code> tryte-encoded seed. If provided, will be used for signing and picking inputs.</li>
<li>**<code>depth</code>** <code>Int</code> depth</li>
<li>**<code>minWeightMagnitude</code>** <code>Int</code> minWeightMagnitude</li>
<li>**<code>transfers</code>**: <code>Array</code> of transfer objects:<ul>
<li>**<code>address</code>**: <code>String</code> 81-tryte encoded address of recipient</li>
<li>**<code>value</code>**: <code>Int</code> value to be transferred.</li>
<li>**<code>message</code>**: <code>String</code> tryte-encoded message to be included in the bundle.</li>
<li>**<code>tag</code>**: <code>String</code> 27-tryte encoded tag.</li>
</ul>
</li>
<li>**<code>options</code>**: <code>Object</code> which is optional:<ul>
<li>**<code>inputs</code>**: <code>Array</code> List of inputs used for funding the transfer</li>
<li>**<code>address</code>**: <code>String</code> if defined, this address will be used for sending the remainder value (of the inputs) to.</li>
</ul>
</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback.</li>
</ol>
<h4>Returns</h4>
<p><code>Array</code> - returns an array of the transfer (transaction objects). </p><hr/>
<h3><code>replayBundle</code></h3>
<p>Takes a tail transaction hash as input, gets the bundle associated with the transaction and then replays the bundle by attaching it to the tangle.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.replayBundle(transaction [, callback])</div></div><!-- fragment --><ol type="1">
<li>**<code>transaction</code>**: <code>String</code> Transaction hash, has to be tail.</li>
<li>**<code>depth</code>** <code>Int</code> depth</li>
<li>**<code>minWeightMagnitude</code>** <code>Int</code> minWeightMagnitude</li>
</ol>
<ol type="1">
<li>**<code>callback</code>**: <code>Function</code> Optional callback <hr/>
</li>
</ol>
<h3><code>broadcastBundle</code></h3>
<p>Takes a tail transaction hash as input, gets the bundle associated with the transaction and then rebroadcasts the entire bundle.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.broadcastBundle(transaction [, callback])</div></div><!-- fragment --><ol type="1">
<li>**<code>transaction</code>**: <code>String</code> Transaction hash, has to be tail.</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback <hr/>
</li>
</ol>
<h3><code>getBundle</code></h3>
<p>This function returns the bundle which is associated with a transaction. Input has to be a tail transaction (i.e. currentIndex = 0). If there are conflicting bundles (because of a replay for example) it will return multiple bundles. It also does important validation checking (signatures, sum, order) to ensure that the correct bundle is returned.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.getBundle(transaction, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>transaction</code>**: <code>String</code> Transaction hash of a tail transaction.</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback</li>
</ol>
<h4>Returns</h4>
<p><code>Array</code> - returns an array of the corresponding bundle of a tail transaction. The bundle itself consists of individual transaction objects. </p><hr/>
<h3><code>getTransfers</code></h3>
<p>Returns the transfers which are associated with a seed. The transfers are determined by either calculating deterministically which addresses were already used, or by providing a list of indexes to get the addresses and the associated transfers from. The transfers are sorted by their timestamp. It should be noted that, because timestamps are not enforced in IOTA, that this may lead to incorrectly sorted bundles (meaning that their chronological ordering in the Tangle is different).</p>
<p>If you want to have your transfers split into received / sent, you can use the utility function <code>categorizeTransfers</code></p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.getTransfers(seed [, options], callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>**: <code>String</code> tryte-encoded seed. It should be noted that this seed is not transferred</li>
<li>**<code>options</code>**: <code>Object</code> which is optional:<ul>
<li>**<code>start</code>**: <code>Int</code> Starting key index for search</li>
<li>**<code>end</code>**: <code>Int</code> Ending key index for search</li>
<li>**<code>security</code>**: <code>Int</code> Security level to be used for the private key / addresses, which is used for getting all associated transfers.</li>
<li>**<code>inclusionStates</code>**: <code>Bool</code> If True, it gets the inclusion states of the transfers.</li>
</ul>
</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback.</li>
</ol>
<h4>Returns</h4>
<p><code>Array</code> - returns an array of transfers. Each array is a bundle for the entire transfer. </p><hr/>
<h3><code>getAccountData</code></h3>
<p>Similar to <code>getTransfers</code>, just a bit more comprehensive in the sense that it also returns the <code>addresses</code>, <code>transfers</code>, <code>inputs</code> and <code>balance</code> that are associated and have been used with your account (seed). This function is useful in getting all the relevant information of your account. If you want to have your transfers split into received / sent, you can use the utility function <code>categorizeTransfers</code></p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.getAccountData(seed [, options], callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>**: <code>String</code> tryte-encoded seed. It should be noted that this seed is not transferred</li>
<li>**<code>options</code>**: <code>Object</code> which is optional:<ul>
<li>**<code>start</code>**: <code>Int</code> Starting key index for search</li>
<li>**<code>end</code>**: <code>Int</code> Ending key index for search</li>
<li>**<code>security</code>**: <code>Int</code> Security level to be used for the private key / addresses, which is used for getting all associated transfers.</li>
</ul>
</li>
<li>**<code>callback</code>**: <code>Function</code> Optional callback.</li>
</ol>
<h4>Returns</h4>
<p><code>Object</code> - returns an object of your account data in the following format: ``` { 'latestAddress': '', // Latest, unused address which has no transactions in the tangle 'addresses': [], // List of all used addresses which have transactions associated with them 'transfers': [], // List of all transfers associated with the addresses 'inputs': [], // List of all inputs available for the seed. Follows the getInputs format of <code>address</code>, <code>balance</code>, <code>security</code> and <code>keyIndex</code> 'balance': 0 // latest confirmed balance } ``` </p><hr/>
<h3><code>isReattachable</code></h3>
<p>This API function helps you to determine whether you should replay a transaction or make a completely new transaction with a different seed. What this function does, is it takes an input address (i.e. from a spent transaction) as input and then checks whether any transactions with a value transferred are confirmed. If yes, it means that this input address has already been successfully used in a different transaction and as such you should no longer replay the transaction.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.api.isReattachable(inputAddress, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>inputAddress</code>**: <code>String | Array</code> address used as input in a transaction. Either string or array.</li>
<li>**<code>callback</code>**: <code>Function</code> callback function</li>
</ol>
<h4>Returns</h4>
<p><code>Bool</code> - true / false (if you provided an array, it's an array of bools) </p><hr/>
<h2><code>iota.utils</code></h2>
<p>All utils function are done synchronously. </p><hr/>
<h3><code>convertUnits</code></h3>
<p>IOTA utilizes the Standard system of Units. See below for all available units:</p>
<div class="fragment"><div class="line">&#39;i&#39;   :   1,</div><div class="line">&#39;Ki&#39;  :   1000,</div><div class="line">&#39;Mi&#39;  :   1000000,</div><div class="line">&#39;Gi&#39;  :   1000000000,</div><div class="line">&#39;Ti&#39;  :   1000000000000,</div><div class="line">&#39;Pi&#39;  :   1000000000000000</div></div><!-- fragment --><p>#### Input </p><div class="fragment"><div class="line">iota.utils.convertUnits(value, fromUnit, toUnit)</div></div><!-- fragment --><ol type="1">
<li>**<code>value</code>**: <code>Integer || String</code> Value to be converted. Can be string, an integer or float.</li>
<li>**<code>fromUnit</code>**: <code>String</code> Current unit of the value. See above for the available units to utilize for conversion.</li>
</ol>
<ol type="1">
<li>**<code>toUnit</code>**: <code>String</code> Unit to convert the from value into.</li>
</ol>
<h4>Returns</h4>
<p><code>Integer</code> - returns the converted unit (fromUnit =&gt; toUnit). </p><hr/>
<h3><code>addChecksum</code></h3>
<p>Takes a tryte-encoded input value and adds a checksum (length is user defined). Standard checksum length is 9 trytes. If <code>isAddress</code> is defined as true, it will validate if it's a correct 81-tryte enocded address.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.addChecksum(inputValue, checksumLength, isAddress)</div></div><!-- fragment --><ol type="1">
<li>**<code>inputValue</code>**: <code>String | List</code> Either an individual tryte value, or a list of tryte values.</li>
<li>**<code>checksumLength</code>**: <code>Int</code> Checksum length. Default is 9 trytes</li>
<li>**<code>isAddress</code>**: <code>Bool</code> indicates whether the input value should be validated as an address (81-trytes). Default is true.</li>
</ol>
<h4>Returns</h4>
<p><code>String | List</code> - returns the input value + checksum either as a string or list, depending on the input. </p><hr/>
<h3><code>noChecksum</code></h3>
<p>Takes an 90-trytes address as input and simply removes the checksum.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.noChecksum(address)</div></div><!-- fragment --><ol type="1">
<li>**<code>address</code>**: <code>String | List</code> 90-trytes address. Either string or a list</li>
</ol>
<h4>Returns</h4>
<p><code>String | List</code> - returns the 81-tryte address(es) </p><hr/>
<h3><code>isValidChecksum</code></h3>
<p>Takes an 90-trytes checksummed address and returns a true / false if it is valid.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.isValidChecksum(addressWithChecksum)</div></div><!-- fragment --><ol type="1">
<li>**<code>addressWithChecksum</code>**: <code>String</code> 90-trytes address</li>
</ol>
<h4>Returns</h4>
<p><code>Bool</code> - True / False whether the checksum is valid or not </p><hr/>
<h3><code>transactionObject</code></h3>
<p>Converts the trytes of a transaction into its transaction object.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.transactionObject(trytes)</div></div><!-- fragment --><ol type="1">
<li>**<code>trytes</code>**: <code>String</code> 2673-trytes of a transaction</li>
</ol>
<h4>Returns</h4>
<p><code>Object</code> - Transaction object </p><hr/>
<h3><code>transactionTrytes</code></h3>
<p>Converts a valid transaction object into trytes. Please refer to [TODO] for more information what a valid transaction object looks like.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.transactionTrytes(transactionObject)</div></div><!-- fragment --><ol type="1">
<li>**<code>transactionObject</code>**: <code>Object</code> valid transaction object</li>
</ol>
<h4>Returns</h4>
<p><code>trytes</code> - converted trytes of </p><hr/>
<h3><code>categorizeTransfers</code></h3>
<p>Categorizes a list of transfers into <code>sent</code> and <code>received</code>. It is important to note that zero value transfers (which for example, is being used for storing addresses in the Tangle), are seen as <code>received</code> in this function.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.categorizeTransfers(transfers, addresses)</div></div><!-- fragment --><ol type="1">
<li>**<code>transfers</code>**: <code>Array</code> A list of bundles. Basically is an array, of arrays (bundles), as is returned from getTransfers or getAccountData</li>
<li>**<code>addresses</code>**: <code>Array</code> List of addresses that belong to you. With these addresses as input, it's determined whether it's a sent or a receive transaction. Therefore make sure that these addresses actually belong to you.</li>
</ol>
<h4>Returns</h4>
<p><code>object</code> - the transfers categorized into <code>sent</code> and <code>received</code></p>
<hr/>
<h3><code>toTrytes</code></h3>
<p>Converts ASCII characters into trytes according to our encoding schema (read the source code for more info as to how it works). Currently only works with valid ASCII characters. As such, if you provide invalid characters the function will return <code>null</code>. In case you want to convert JSON data, stringify it first.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.toTrytes(input)</div></div><!-- fragment --><ol type="1">
<li>**<code>input</code>**: <code>String</code> String you want to convert into trytes. All non-string values should be converted into strings first.</li>
</ol>
<h4>Returns</h4>
<p><code>string || null</code> - trytes, or null in case you provided an invalid ASCII character </p><hr/>
<h3><code>fromTrytes</code></h3>
<p>Reverse of toTrytes.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.fromTrytes(trytes)</div></div><!-- fragment --><ol type="1">
<li>**<code>trytes</code>**: <code>String</code> Trytes you want to convert to string</li>
</ol>
<h4>Returns</h4>
<p><code>string</code> - string </p><hr/>
<h3><code>extractJson</code></h3>
<p>This function takes a bundle as input and from the signatureMessageFragments extracts the JSON encoded data which was sent with the transfer. This currently only works with the <code>toTrytes</code> and <code>fromTrytes</code> function that use the ASCII &lt;-&gt; Trytes encoding scheme. In case there is no JSON data, or invalid one, this function will return <code>null</code></p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.extractJson(bundle)</div></div><!-- fragment --><ol type="1">
<li>**<code>bundle</code>**: <code>Array</code> bundle from which you want to extract the JSON data.</li>
</ol>
<h4>Returns</h4>
<p><code>String</code> - Stringified JSON object which was extracted from the transactions. </p><hr/>
<h3><code>validateSignatures</code></h3>
<p>This function makes it possible for each of the co-signers in the multi-signature to independently verify that a generated transaction with the corresponding signatures of the co-signers is valid. This function is safe to use and does not require any sharing of digests or key values.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.validateSignatures(signedBundle, inputAddress)</div></div><!-- fragment --><ol type="1">
<li>**<code>signedBundle</code>**: <code>Array</code> signed bundle by all of the co-signers</li>
<li>**<code>inputAddress</code>**: <code>String</code> input address as provided to <code>initiateTransfer</code>.</li>
</ol>
<h4>Returns</h4>
<p><code>bool</code> - true / false </p><hr/>
<h3><code>isBundle</code></h3>
<p>Checks if the provided bundle is valid. The provided bundle has to be ordered tail (i.e. <code>currentIndex</code>: 0) first. A bundle is deemed valid if it has:</p>
<ul>
<li>Valid transaction structure</li>
<li>Correct <code>currentIndex</code>, <code>lastIndex</code> and number of bundle transactions</li>
<li>The sum of all <code>value</code> fields is 0</li>
<li>The bundle hash is correct</li>
<li>Valid signature <hr/>
</li>
</ul>
<p>#### Input </p><div class="fragment"><div class="line">iota.utils.isBundle(bundle)</div></div><!-- fragment --><ol type="1">
<li>**<code>bundle</code>**: <code>Array</code> bundle to test</li>
</ol>
<h4>Returns</h4>
<p><code>bool</code> - true / false </p><hr/>
<h2><code>iota.multisig</code></h2>
<p>Multi signature related functions.</p>
<blockquote class="doxtable">
<p><b>VERY IMPORTANT NOTICE</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>Before using these functions, please make sure that you have thoroughly read our https://github.com/iotaledger/wiki/blob/master/multisigs.md "guidelines for multi-signature". It is of utmost importance that you follow these rules, else it can potentially lead to financial losses. </p>
</blockquote>
<hr/>
<h3><code>getKey</code></h3>
<p>Generates the corresponding private key (depending on the <code>security</code> chosen) of a seed.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.multisig.getKey(seed, index, security)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>**: <code>String</code> Tryte encoded seed</li>
<li>**<code>index</code>**: 'Int' Index of the private key.</li>
<li>**<code>security</code>**: <code>Int</code> Security level to be used for the private key</li>
</ol>
<h4>Returns</h4>
<p><code>String</code> - private key represented in trytes.</p>
<hr/>
<h3><code>getDigest</code></h3>
<p>Generates the digest value of a key.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.multisig.getDigest(seed, index)</div></div><!-- fragment --><ol type="1">
<li>**<code>seed</code>**: <code>String</code> Tryte encoded seed</li>
<li>**<code>index</code>**: 'Int' Index of the private key.</li>
<li>**<code>security</code>**: <code>Int</code> Security level to be used for the private key</li>
</ol>
<h4>Returns</h4>
<p><code>String</code> - digest represented in trytes. </p><hr/>
<h3><code>address</code></h3>
<p>This function is used to initiate the creation of a new multisig address. Once all digests were added with <code>addDigest()</code>, <code>finalize()</code> can be used to get the actual 81-tryte address value. <code>validateAddress()</code> can be used to actually validate the multi-signature.</p>
<p>#### Input </p><div class="fragment"><div class="line">var address = new iota.multisig.address(digests);</div></div><!-- fragment --><ol type="1">
<li>**<code>digestTrytes</code>**: <code>String || Array</code> Optional string or array of digest trytes as returned by <code>getDigest</code></li>
</ol>
<h4>Returns</h4>
<p><code>Object</code> - multisig address instance </p><hr/>
<h3><code>address.absorb</code></h3>
<p>Absorbs the digests of co-signers</p>
<p>#### Input </p><div class="fragment"><div class="line">address.addDigest(digest);</div></div><!-- fragment --><ol type="1">
<li>**<code>digest</code>**: <code>String || Array</code> String or array of digest trytes as returned by <code>getDigest</code></li>
</ol>
<h4>Returns</h4>
<p><code>Object</code> - multisig address instance </p><hr/>
<h3><code>address.finalize</code></h3>
<p>Finalizes the multisig address generation process and returns the correct 81-tryte address.</p>
<p>#### Input </p><div class="fragment"><div class="line">address.finalize()</div></div><!-- fragment --><h4>Returns</h4>
<p><code>String</code> - 81-tryte multisig address</p>
<hr/>
<h3><code>validateAddress</code></h3>
<p>Validates a generated multi-sig address by getting the corresponding key digests of each of the co-signers. The order of the digests is of essence in getting correct results.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.multisig.validateAddress(multisigAddress, digests)</div></div><!-- fragment --><ol type="1">
<li>**<code>multisigAddress</code>**: <code>String</code> digest trytes as returned by <code>getDigest</code></li>
<li>**<code>digests</code>**: 'Array' array of the key digest for each of the cosigners. The digests need to be provided in the correct signing order.</li>
</ol>
<h4>Returns</h4>
<p><code>Bool</code> - true / false </p><hr/>
<h3><code>initiateTransfer</code></h3>
<p>Initiates the creation of a new transfer by generating an empty bundle with the correct number of bundle entries to be later used for the signing process. It should be noted that currently, only a single input (via <code>inputAddress</code>) is possible. The <code>remainderAddress</code> also has to be provided and should be generated by the co-signers of the multi-signature before initiating the transfer.</p>
<p>The <code>securitySum</code> input is basically the sum of the <code>security</code> levels from all cosigners chosen during the private key generation (getKey / getDigest). e.g. when creating a new multisig, Bob has chosen security level 2, whereas Charles has chosen security level 3. Their securitySum is 5.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.multisig.initiateTransfer(securitySum, inputAddress, remainderAddress, transfers, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>securitySum</code>**: <code>Int</code> The sum of the security levels chosen by all cosigners when generating the private keys.</li>
<li>**<code>inputAddress</code>**: <code>String</code> input address which has sufficient balance and is controlled by the co-signers</li>
<li>**<code>remainderAddress</code>**: <code>String</code> in case there is a remainder balance, send the funds to this address. If you do not have a remainder balance, you can simply put <code>null</code></li>
<li>**<code>transfers</code>**: <code>Array</code> Transfers object</li>
<li>**<code>callback</code>**: <code>Function</code></li>
</ol>
<h4>Returns</h4>
<p><code>Array</code> - bundle </p><hr/>
<h3><code>addSignature</code></h3>
<p>This function is called by each of the co-signers individually to add their signature to the bundle. Here too, order is important. This function returns the bundle, which should be shared with each of the participants of the multi-signature.</p>
<p>After having added all signatures, you can validate the signature with the <code>utils.validateSignature()</code> function.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.multisig.addSignature(bundleToSign, inputAddress, key, callback)</div></div><!-- fragment --><ol type="1">
<li>**<code>bundleToSign</code>**: <code>Array</code> bundle to sign</li>
<li>**<code>inputAddress</code>**: <code>String</code> input address as provided to <code>initiateTransfer</code>.</li>
<li>**<code>key</code>**: <code>String</code> private key trytes as returned by <code>getKey</code></li>
<li>**<code>callback</code>**: <code>Function</code></li>
</ol>
<h4>Returns</h4>
<p><code>Array</code> - bundle </p><hr/>
<h2><code>iota.valid</code></h2>
<p>Validator functions. Return either true / false. </p><hr/>
<h3><code>isAddress</code></h3>
<p>Checks if the provided input is a valid 81-tryte (non-checksum), or 90-tryte (with checksum) address.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isAddress(address)</div></div><!-- fragment --><ol type="1">
<li>**<code>address</code>**: <code>String</code> A single address <hr/>
</li>
</ol>
<h3><code>isTrytes</code></h3>
<p>Determines if the provided input is valid trytes. Valid trytes are: <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ9</code>. If you specify the length parameter, you can also validate the input length.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isTrytes(trytes [, length])</div></div><!-- fragment --><ol type="1">
<li>**<code>trytes</code>**: <code>String</code></li>
<li>**<code>length</code>**: <code>int || string</code> optional <hr/>
</li>
</ol>
<h3><code>isValue</code></h3>
<p>Validates the value input, checks if it's integer.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isValue(value)</div></div><!-- fragment --><ol type="1">
<li>**<code>value</code>**: <code>Integer</code> <hr/>
</li>
</ol>
<h3><code>isNum</code></h3>
<p>Checks if the input value is a number, can be a string, float or integer.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isNum(value)</div></div><!-- fragment --><ol type="1">
<li>**<code>value</code>**: <code>Integer</code> <hr/>
</li>
</ol>
<h3><code>isHash</code></h3>
<p>Checks if correct hash consisting of 81-trytes.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isHash(hash)</div></div><!-- fragment --><ol type="1">
<li>**<code>hash</code>**: <code>String</code> <hr/>
</li>
</ol>
<h3><code>isTransfersArray</code></h3>
<p>Checks if it's a correct array of transfer objects. A transfer object consists of the following values: </p><div class="fragment"><div class="line">{</div><div class="line">    &#39;address&#39;: // STRING (trytes encoded, 81 or 90 trytes)</div><div class="line">    &#39;value&#39;: // INT</div><div class="line">    &#39;message&#39;: // STRING (trytes encoded)</div><div class="line">    &#39;tag&#39;: // STRING (trytes encoded, maximum 27 trytes)</div><div class="line">}</div></div><!-- fragment --><p>#### Input </p><div class="fragment"><div class="line">iota.valid.isTransfersArray(transfersArray)</div></div><!-- fragment --><ol type="1">
<li>**<code>transfersArray</code>**: <code>array</code> <hr/>
</li>
</ol>
<h3><code>isArrayOfHashes</code></h3>
<p>Array of valid 81 or 90-trytes hashes.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isArrayOfHashes(hashesArray)</div></div><!-- fragment --><ol type="1">
<li>**<code>hashesArray</code>**: <code>Array</code> <hr/>
</li>
</ol>
<h3><code>isArrayOfTrytes</code></h3>
<p>Checks if it's an array of correct 2673-trytes. These are trytes either returned by prepareTransfers, attachToTangle or similar call. A single transaction object is encoded 2673 trytes.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isArrayOfTrytes(trytesArray)</div></div><!-- fragment --><ol type="1">
<li>**<code>trytesArray</code>**: <code>Array</code> <hr/>
</li>
</ol>
<h3><code>isArrayOfAttachedTrytes</code></h3>
<p>Similar to <code>isArrayOfTrytes</code>, just that in addition this function also validates that the last 243 trytes are non-zero (meaning that they don't equal 9). The last 243 trytes consist of: <code>trunkTransaction</code> + <code>branchTransaction</code> + <code>nonce</code>. As such, this function determines whether the provided trytes have been attached to the tangle successfully. For example this validator can be used for trytes returned by <code>attachToTangle</code>.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isArrayOfAttachedTrytes(trytesArray)</div></div><!-- fragment --><ol type="1">
<li>**<code>trytesArray</code>**: <code>Array</code> <hr/>
</li>
</ol>
<h3><code>isArrayOfTxObjects</code></h3>
<p>Checks if the provided bundle is an array of correct transaction objects. Basically validates if each entry in the array has all of the following keys: </p><div class="fragment"><div class="line">var keys = [</div><div class="line">    &#39;hash&#39;,</div><div class="line">    &#39;signatureMessageFragment&#39;,</div><div class="line">    &#39;address&#39;,</div><div class="line">    &#39;value&#39;,</div><div class="line">    &#39;tag&#39;,</div><div class="line">    &#39;timestamp&#39;,</div><div class="line">    &#39;currentIndex&#39;,</div><div class="line">    &#39;lastIndex&#39;,</div><div class="line">    &#39;bundle&#39;,</div><div class="line">    &#39;trunkTransaction&#39;,</div><div class="line">    &#39;branchTransaction&#39;,</div><div class="line">    &#39;nonce&#39;</div><div class="line">]</div></div><!-- fragment --><p>#### Input </p><div class="fragment"><div class="line">iota.valid.isArrayOfTxObjects(bundle)</div></div><!-- fragment --><ol type="1">
<li>**<code>bundle</code>**: <code>Array</code> <hr/>
</li>
</ol>
<h3><code>isInputs</code></h3>
<p>Validates if it's an array of correct input objects. These inputs are provided to either <code>prepareTransfers</code> or <code>sendTransfer</code>. An input objects consists of the following:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &#39;keyIndex&#39;: // INT</div><div class="line">    &#39;address&#39;: // STRING</div><div class="line">}</div></div><!-- fragment --><p>#### Input </p><div class="fragment"><div class="line">iota.valid.isInputs(inputsArray)</div></div><!-- fragment --><ol type="1">
<li>**<code>inputsArray</code>**: <code>Array</code> <hr/>
</li>
</ol>
<h3><code>isString</code></h3>
<p>Self explanatory.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isString(string)</div></div><!-- fragment --> <hr/>
<h3><code>isArray</code></h3>
<p>Self explanatory.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isArray(array)</div></div><!-- fragment --> <hr/>
<h3><code>isObject</code></h3>
<p>Self explanatory.</p>
<p>#### Input </p><div class="fragment"><div class="line">iota.valid.isObject(array)</div></div><!-- fragment --> <hr/>
<h3><code>isUri</code></h3>
<p>Validates a given string to check if it's a valid IPv6, IPv4 or hostname format. The string must have a <code>udp://</code> prefix, and it may or may not have a port. Here are some example inputs:</p>
<div class="fragment"><div class="line">udp://[2001:db8:a0b:12f0::1]:14265</div><div class="line">udp://[2001:db8:a0b:12f0::1]</div><div class="line">udp://8.8.8.8:14265</div><div class="line">udp://domain.com</div><div class="line">udp://domain2.com:14265</div></div><!-- fragment --><p>#### Input </p><div class="fragment"><div class="line">iota.utils.isUri(node)</div></div><!-- fragment --><ol type="1">
<li>**<code>node</code>**: <code>String</code> IPv6, IPv4 or Hostname with or without a port.</li>
</ol>
<h4>Returns</h4>
<p><code>bool</code> - true/false if valid node format. </p><hr/>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
