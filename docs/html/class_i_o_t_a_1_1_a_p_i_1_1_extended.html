<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iota.lib.cpp: IOTA::API::Extended Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iota.lib.cpp
   </div>
   <div id="projectbrief">IOTA C++ Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>IOTA</b></li><li class="navelem"><b>API</b></li><li class="navelem"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html">Extended</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_o_t_a_1_1_a_p_i_1_1_extended-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IOTA::API::Extended Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="extended_8hpp_source.html">extended.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IOTA::API::Extended:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_i_o_t_a_1_1_a_p_i_1_1_extended.png" usemap="#IOTA::API::Extended_map" alt=""/>
  <map id="IOTA::API::Extended_map" name="IOTA::API::Extended_map">
<area href="class_i_o_t_a_1_1_a_p_i_1_1_core.html" alt="IOTA::API::Core" shape="rect" coords="0,0,125,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3cff06d7db95d4fefedde93dc7ab7155"><td class="memItemLeft" align="right" valign="top"><a id="a3cff06d7db95d4fefedde93dc7ab7155"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Extended</b> (const std::string &amp;host, const uint16_t &amp;port, Crypto::SpongeType cryptoType=Crypto::SpongeType::KERL)</td></tr>
<tr class="separator:a3cff06d7db95d4fefedde93dc7ab7155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eae27d3d28afb3a33ae299a0d000311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a9eae27d3d28afb3a33ae299a0d000311">getInputs</a> (const Types::Trytes &amp;seed, const int32_t &amp;start, const int32_t &amp;end, const int32_t &amp;security, const int64_t &amp;threshold) const</td></tr>
<tr class="separator:a9eae27d3d28afb3a33ae299a0d000311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772142ff323308ac482d6e9e477ff188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a772142ff323308ac482d6e9e477ff188">getBalancesAndFormat</a> (const std::vector&lt; Types::Trytes &gt; &amp;addresses, const int64_t &amp;threshold, const int32_t &amp;start, const int32_t &amp;security, const <a class="el" href="class_i_o_t_a_1_1_utils_1_1_stop_watch.html">Utils::StopWatch</a> &amp;stopWatch={}) const</td></tr>
<tr class="separator:a772142ff323308ac482d6e9e477ff188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bddb596cdf2770981ab05485c9dfe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_new_addresses.html">Responses::GetNewAddresses</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a05bddb596cdf2770981ab05485c9dfe8">getNewAddresses</a> (const Types::Trytes &amp;seed, const uint32_t &amp;index=0, const int32_t &amp;security=2, bool checksum=false, const int32_t &amp;total=0, bool returnAll=false) const</td></tr>
<tr class="separator:a05bddb596cdf2770981ab05485c9dfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5c4d33e956c0d76f98aa5a7a1c6f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a7b5c4d33e956c0d76f98aa5a7a1c6f8f">traverseBundle</a> (const Types::Trytes &amp;trunkTx) const</td></tr>
<tr class="separator:a7b5c4d33e956c0d76f98aa5a7a1c6f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395484ad3ff8c373adb8c981b4f79cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a395484ad3ff8c373adb8c981b4f79cd3">traverseBundle</a> (const Types::Trytes &amp;trunkTx, Types::Trytes bundleHash, <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;bundle) const</td></tr>
<tr class="separator:a395484ad3ff8c373adb8c981b4f79cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74137fc615af252ddd333d125c841aff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a74137fc615af252ddd333d125c841aff">bundlesFromAddresses</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;addresses, bool inclusionStates) const</td></tr>
<tr class="separator:a74137fc615af252ddd333d125c841aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab859e793034efb304994645f21e1d665"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ab859e793034efb304994645f21e1d665">findTransactionObjects</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;addresses) const</td></tr>
<tr class="separator:ab859e793034efb304994645f21e1d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a60cc7653363fb3467ed2db45d1cb48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a9a60cc7653363fb3467ed2db45d1cb48">getTransactionsObjects</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;trx_hashes) const</td></tr>
<tr class="separator:a9a60cc7653363fb3467ed2db45d1cb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c729f792d8b7154a810a7e0df7ed3d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a5c729f792d8b7154a810a7e0df7ed3d8">findTransactionObjectsByBundle</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;input) const</td></tr>
<tr class="separator:a5c729f792d8b7154a810a7e0df7ed3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80dbd20f6efcabe5234fff81bfde6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ad80dbd20f6efcabe5234fff81bfde6fe">getLatestInclusion</a> (const std::vector&lt; Types::Trytes &gt; &amp;hashes) const</td></tr>
<tr class="separator:ad80dbd20f6efcabe5234fff81bfde6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699d47d59998dcb5c4c377dd7dfeb9fc"><td class="memItemLeft" align="right" valign="top"><a id="a699d47d59998dcb5c4c377dd7dfeb9fc"></a>
std::vector&lt; Types::Trytes &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>prepareTransfers</b> (const Types::Trytes &amp;seed, int security, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers, const std::string &amp;remainder, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, bool validateInputs=true) const</td></tr>
<tr class="separator:a699d47d59998dcb5c4c377dd7dfeb9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0bbe508888acfe6f97aca3d9e0da86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_bundle.html">Responses::GetBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#aae0bbe508888acfe6f97aca3d9e0da86">getBundle</a> (const Types::Trytes &amp;transaction) const</td></tr>
<tr class="separator:aae0bbe508888acfe6f97aca3d9e0da86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0c8ce7b3af87a350a5a47cc0b2bbb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transfers.html">Responses::GetTransfers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#adc0c8ce7b3af87a350a5a47cc0b2bbb6">getTransfers</a> (const Types::Trytes &amp;seed, int start, int end, int security, bool inclusionStates) const</td></tr>
<tr class="separator:adc0c8ce7b3af87a350a5a47cc0b2bbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce339b570682f2c559abf35fb57388b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a0ce339b570682f2c559abf35fb57388b">replayTransfer</a> () const</td></tr>
<tr class="separator:a0ce339b570682f2c559abf35fb57388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2687ef56ef0340cd21be97f4d359f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_send_transfer.html">Responses::SendTransfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a9e2687ef56ef0340cd21be97f4d359f8">sendTransfer</a> (const Types::Trytes &amp;seed, int security, int depth, int minWeightMagnitude, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, const Types::Trytes &amp;address) const</td></tr>
<tr class="separator:a9e2687ef56ef0340cd21be97f4d359f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1d2f616a5fa494dfaedf4891f26fb3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a0e1d2f616a5fa494dfaedf4891f26fb3">sendTrytes</a> (const std::vector&lt; Types::Trytes &gt; &amp;trytes, const unsigned int &amp;depth, const unsigned int &amp;minWeightMagnitude) const</td></tr>
<tr class="separator:a0e1d2f616a5fa494dfaedf4891f26fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84894cbaa3fa57252a8a34a75e0d7ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#aa84894cbaa3fa57252a8a34a75e0d7ab">broadcastAndStore</a> (const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:aa84894cbaa3fa57252a8a34a75e0d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaa343b818b96bac952af0064f627ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#afeaa343b818b96bac952af0064f627ae">findTransactionsByAddresses</a> (const std::vector&lt; Types::Trytes &gt; &amp;addresses) const</td></tr>
<tr class="separator:afeaa343b818b96bac952af0064f627ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca099d07a68a3ec8b25d5f834efbce09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#aca099d07a68a3ec8b25d5f834efbce09">findTransactionsByTags</a> (const std::vector&lt; Types::Trytes &gt; &amp;tags) const</td></tr>
<tr class="separator:aca099d07a68a3ec8b25d5f834efbce09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93356e4fafc265bb4e3974c9ed74f521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a93356e4fafc265bb4e3974c9ed74f521">findTransactionsByApprovees</a> (const std::vector&lt; Types::Trytes &gt; &amp;approvees) const</td></tr>
<tr class="separator:a93356e4fafc265bb4e3974c9ed74f521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3e80e5cd620fbeaf43a854b68a674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a51c3e80e5cd620fbeaf43a854b68a674">findTransactionsByBundles</a> (const std::vector&lt; Types::Trytes &gt; &amp;bundles) const</td></tr>
<tr class="separator:a51c3e80e5cd620fbeaf43a854b68a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddf57575e603370895cf3afbaa2b971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_account_data.html">Responses::GetAccountData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a5ddf57575e603370895cf3afbaa2b971">getAccountData</a> (const Types::Trytes &amp;seed, int index, int security, bool checksum, int total, bool returnAll, int start, int end, bool inclusionStates, long threshold) const</td></tr>
<tr class="separator:a5ddf57575e603370895cf3afbaa2b971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84744f17dd0c8f5b8b26062aff52d473"><td class="memItemLeft" align="right" valign="top">Types::Trytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a84744f17dd0c8f5b8b26062aff52d473">findTailTransactionHash</a> (const Types::Trytes &amp;hash) const</td></tr>
<tr class="separator:a84744f17dd0c8f5b8b26062aff52d473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e239dd0926b8561fc333c8bc69eeb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Types::Trytes &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a340e239dd0926b8561fc333c8bc69eeb">addRemainder</a> (const Types::Trytes &amp;seed, const unsigned int &amp;security, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;bundle, const Types::Trytes &amp;tag, const int64_t &amp;totalValue, const Types::Trytes &amp;remainderAddress, const std::vector&lt; Types::Trytes &gt; &amp;signatureFragments) const</td></tr>
<tr class="separator:a340e239dd0926b8561fc333c8bc69eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489a5b783b9e585e948548b32a24fdf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_replay_bundle.html">Responses::ReplayBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a489a5b783b9e585e948548b32a24fdf3">replayBundle</a> (const Types::Trytes &amp;transaction, int depth, int minWeightMagnitude)</td></tr>
<tr class="separator:a489a5b783b9e585e948548b32a24fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c237db6d1ccff2417613496a651bc9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ad5c237db6d1ccff2417613496a651bc9">initiateTransfer</a> (int securitySum, const Types::Trytes &amp;inputAddress, const Types::Trytes &amp;remainderAddress, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers) const</td></tr>
<tr class="separator:ad5c237db6d1ccff2417613496a651bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html">IOTA::API::Core</a></td></tr>
<tr class="memitem:adc5fde5ce7507142ee53e80462914a70 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="adc5fde5ce7507142ee53e80462914a70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Core</b> (const std::string &amp;host, const uint16_t &amp;port)</td></tr>
<tr class="separator:adc5fde5ce7507142ee53e80462914a70 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d616c9db7893159f16ec1b0356927f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="aa9d616c9db7893159f16ec1b0356927f"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_node_info.html">Responses::GetNodeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeInfo</b> () const</td></tr>
<tr class="separator:aa9d616c9db7893159f16ec1b0356927f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23af5efc04e5a04daf7c19014eb0d0b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ab23af5efc04e5a04daf7c19014eb0d0b"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_neighbors.html">Responses::GetNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNeighbors</b> () const</td></tr>
<tr class="separator:ab23af5efc04e5a04daf7c19014eb0d0b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367bd6329e56491bdb624c083a1b0902 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a367bd6329e56491bdb624c083a1b0902"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_add_neighbors.html">Responses::AddNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addNeighbors</b> (const std::vector&lt; std::string &gt; &amp;uris) const</td></tr>
<tr class="separator:a367bd6329e56491bdb624c083a1b0902 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420b7aa62e8f87bb844063efab9a8c7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a1420b7aa62e8f87bb844063efab9a8c7"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_remove_neighbors.html">Responses::RemoveNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>removeNeighbors</b> (const std::vector&lt; std::string &gt; &amp;uris) const</td></tr>
<tr class="separator:a1420b7aa62e8f87bb844063efab9a8c7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add317bef9e8d4f2e4eaec3e4b5c7e205 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="add317bef9e8d4f2e4eaec3e4b5c7e205"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_tips.html">Responses::GetTips</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTips</b> () const</td></tr>
<tr class="separator:add317bef9e8d4f2e4eaec3e4b5c7e205 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554184bb1ea1e50e77e2097d75a9cdb0 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#a554184bb1ea1e50e77e2097d75a9cdb0">findTransactions</a> (const std::vector&lt; Types::Trytes &gt; &amp;addresses, const std::vector&lt; Types::Trytes &gt; &amp;tags, const std::vector&lt; Types::Trytes &gt; &amp;approvees, const std::vector&lt; Types::Trytes &gt; &amp;bundles) const</td></tr>
<tr class="separator:a554184bb1ea1e50e77e2097d75a9cdb0 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f5cdbb41044f62c491f2dab06bf52b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ad6f5cdbb41044f62c491f2dab06bf52b"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_trytes.html">Responses::GetTrytes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTrytes</b> (const std::vector&lt; Types::Trytes &gt; &amp;hashes) const</td></tr>
<tr class="separator:ad6f5cdbb41044f62c491f2dab06bf52b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fa48b2ebe2fff583b65feb791804a6 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ae0fa48b2ebe2fff583b65feb791804a6"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInclusionStates</b> (const std::vector&lt; Types::Trytes &gt; &amp;transactions, const std::vector&lt; Types::Trytes &gt; &amp;tips) const</td></tr>
<tr class="separator:ae0fa48b2ebe2fff583b65feb791804a6 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869c73d1cff5cad00e654258a557c51f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a869c73d1cff5cad00e654258a557c51f"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances.html">Responses::GetBalances</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBalances</b> (const std::vector&lt; Types::Trytes &gt; &amp;addresses, const int &amp;threshold) const</td></tr>
<tr class="separator:a869c73d1cff5cad00e654258a557c51f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fe78e987cc4b0ca292b35c733da4e8 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ad2fe78e987cc4b0ca292b35c733da4e8"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transactions_to_approve.html">Responses::GetTransactionsToApprove</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTransactionsToApprove</b> (const int &amp;depth) const</td></tr>
<tr class="separator:ad2fe78e987cc4b0ca292b35c733da4e8 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb57e8a6ba98be6947b008edcb4f8a4 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="addb57e8a6ba98be6947b008edcb4f8a4"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_attach_to_tangle.html">Responses::AttachToTangle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>attachToTangle</b> (const Types::Trytes &amp;trunkTransaction, const Types::Trytes &amp;branchTransaction, const int &amp;minWeightMagnitude, const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:addb57e8a6ba98be6947b008edcb4f8a4 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1779df873b2877aa4ae87421ff947c72 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a1779df873b2877aa4ae87421ff947c72"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><b>interruptAttachingToTangle</b> () const</td></tr>
<tr class="separator:a1779df873b2877aa4ae87421ff947c72 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9605f23dae0920d286d208a5ad806e inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a0f9605f23dae0920d286d208a5ad806e"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><b>broadcastTransactions</b> (const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:a0f9605f23dae0920d286d208a5ad806e inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fc2694189aacb9b1f55a1664661b84 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a31fc2694189aacb9b1f55a1664661b84"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><b>storeTransactions</b> (const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:a31fc2694189aacb9b1f55a1664661b84 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html">Extended</a> API calls which will help do just about anything possible with IOTA. These are mostly wrapper functions of <a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html">Core</a> API calls. <a href="https://github.com/iotaledger/wiki/blob/master/api-proposal.md#proposed-api-calls">https://github.com/iotaledger/wiki/blob/master/api-proposal.md#proposed-api-calls</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a340e239dd0926b8561fc333c8bc69eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340e239dd0926b8561fc333c8bc69eeb">&#9670;&nbsp;</a></span>addRemainder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Types::Trytes &gt; IOTA::API::Extended::addRemainder </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>totalValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>remainderAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>signatureFragments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">inputs</td><td>List of inputs used for funding the transfer. </td></tr>
    <tr><td class="paramname">bundle</td><td>To be populated. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag. </td></tr>
    <tr><td class="paramname">totalValue</td><td>The total value. </td></tr>
    <tr><td class="paramname">remainderAddress</td><td>If defined, this address will be used for sending the remainder value (of the inputs) to. </td></tr>
    <tr><td class="paramname">signatureFragments</td><td>The signature fragments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa84894cbaa3fa57252a8a34a75e0d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84894cbaa3fa57252a8a34a75e0d7ab">&#9670;&nbsp;</a></span>broadcastAndStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a> IOTA::API::Extended::broadcastAndStore </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>trytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function that does broadcastTransactions and storeTransactions. </p>

</div>
</div>
<a id="a74137fc615af252ddd333d125c841aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74137fc615af252ddd333d125c841aff">&#9670;&nbsp;</a></span>bundlesFromAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &gt; IOTA::API::Extended::bundlesFromAddresses </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function to get the formatted bundles of a list of addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>List of addresses. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bundles </dd></dl>
<p>find transactions for addresses</p>
<p>filter tail/non tail transactions</p>
<p>find transactions for bundles of non tail transactions TODO: this will maybe re-query some tail transactions we already got (and we do filter that out in the next for loop) we maybe can filter the bundle list passed to findTransactionObjectsByBundle by restructuring the previous loop</p>
<p>add tail transactions found with findTransactionObjectsByBundle </p>

</div>
</div>
<a id="a84744f17dd0c8f5b8b26062aff52d473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84744f17dd0c8f5b8b26062aff52d473">&#9670;&nbsp;</a></span>findTailTransactionHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Types::Trytes IOTA::API::Extended::findTailTransactionHash </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash of a transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash of the tail transaction of the bundle to which the input trx belongs or EmptyHash </dd></dl>
<p>check if current trx is tail</p>
<p>if not, fetch based on bundle hash </p>

</div>
</div>
<a id="ab859e793034efb304994645f21e1d665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab859e793034efb304994645f21e1d665">&#9670;&nbsp;</a></span>findTransactionObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::findTransactionObjects </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup transactions for given addresses and return a list of transaction objects</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>Addresses for which transactions objects should be found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions. </dd></dl>
<p>get the transaction objects of the transactions </p>

</div>
</div>
<a id="a5c729f792d8b7154a810a7e0df7ed3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c729f792d8b7154a810a7e0df7ed3d8">&#9670;&nbsp;</a></span>findTransactionObjectsByBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::findTransactionObjectsByBundle </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as findTransactionObjects, but based on bundle hash</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Bundle hashes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions. </dd></dl>

</div>
</div>
<a id="afeaa343b818b96bac952af0064f627ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaa343b818b96bac952af0064f627ae">&#9670;&nbsp;</a></span>findTransactionsByAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByAddresses </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>The list of addresses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transactions which have the specified address as an input/output field. </dd></dl>

</div>
</div>
<a id="a93356e4fafc265bb4e3974c9ed74f521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93356e4fafc265bb4e3974c9ed74f521">&#9670;&nbsp;</a></span>findTransactionsByApprovees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByApprovees </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>approvees</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified approvees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">approvees</td><td>The list of approvees of a transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transaction which reference (i.e. confirm) the specified transactions. </dd></dl>

</div>
</div>
<a id="a51c3e80e5cd620fbeaf43a854b68a674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c3e80e5cd620fbeaf43a854b68a674">&#9670;&nbsp;</a></span>findTransactionsByBundles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByBundles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>bundles</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified bundles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundles</td><td>The list of bundle hashes that need to be extended to 81 chars by padding the hash with 9's.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transactions which contain the specified bundle hash. </dd></dl>

</div>
</div>
<a id="aca099d07a68a3ec8b25d5f834efbce09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca099d07a68a3ec8b25d5f834efbce09">&#9670;&nbsp;</a></span>findTransactionsByTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByTags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>tags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>The list of transaction tags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transactions which contain the specified tag value. </dd></dl>

</div>
</div>
<a id="a5ddf57575e603370895cf3afbaa2b971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddf57575e603370895cf3afbaa2b971">&#9670;&nbsp;</a></span>getAccountData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_account_data.html">Responses::GetAccountData</a> IOTA::API::Extended::getAccountData </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnAll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to getTransfers, just that it returns additional account data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>The Security level of private key / seed. </td></tr>
    <tr><td class="paramname">index</td><td>Key index to start search from. If the index is provided, the generation of the address is not deterministic. Default is 0. </td></tr>
    <tr><td class="paramname">checksum</td><td>Adds 9-tryte address checksum. </td></tr>
    <tr><td class="paramname">total</td><td>Total number of addresses to generate. 0 for unlimited </td></tr>
    <tr><td class="paramname">returnAll</td><td>If <code>true</code>, it returns all addresses which were deterministically generated (until findTransactions returns null). </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. 0 to skip. </td></tr>
    <tr><td class="paramname">end</td><td>Ending key index. 0 to skip. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers. </td></tr>
    <tr><td class="paramname">threshold</td><td>Min balance required. 0 to skip. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a772142ff323308ac482d6e9e477ff188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772142ff323308ac482d6e9e477ff188">&#9670;&nbsp;</a></span>getBalancesAndFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a> IOTA::API::Extended::getBalancesAndFormat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_utils_1_1_stop_watch.html">Utils::StopWatch</a> &amp;&#160;</td>
          <td class="paramname"><em>stopWatch</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the balances and formats the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>The addresses. </td></tr>
    <tr><td class="paramname">threshold</td><td>Min balance required. </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">stopWatch</td><td>the stopwatch. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inputs object. </dd></dl>
<p>retrieve balances for all given addresses</p>
<p>retrieve balance for given address</p>
<p>skip if no balance</p>
<p>Add input to result and increase totalBalance of all aggregated inputs</p>
<p>TODO: is this break necessary? (that's the logic of the reference java client) threshold is defined as minimum balance expected, but here we stop the process whenever threshold is reached (if different from 0) so is it an expected behavior? If so, why so? Maybe we will get more clues further during the development of other API </p>

</div>
</div>
<a id="aae0bbe508888acfe6f97aca3d9e0da86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0bbe508888acfe6f97aca3d9e0da86">&#9670;&nbsp;</a></span>getBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_bundle.html">Responses::GetBundle</a> IOTA::API::Extended::getBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>transaction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the associated bundle transactions of a single transaction Does validation of signatures, total sum as well as bundle order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transaction</td><td>Hash of a tail transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of transactions belonging to bundle corresponding to the input trx </dd></dl>
<p>get bundle hash for transaction</p>
<p>init curl</p>
<p>sums up transaction values</p>
<p>Absorb bundle hash + value + timestamp + lastIndex + currentIndex trytes.</p>
<p>if transaction has some value, we can processs next transactions</p>
<p>Find the subsequent txs with the remaining signature fragment</p>
<p>Check for total sum, if not equal 0 return error</p>
<p>Check if bundle hash is the same as returned by tx object</p>
<p>Last tx in the bundle should have currentIndex == lastIndex</p>
<p>Validate the signatures </p>

</div>
</div>
<a id="a9eae27d3d28afb3a33ae299a0d000311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eae27d3d28afb3a33ae299a0d000311">&#9670;&nbsp;</a></span>getInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a> IOTA::API::Extended::getInputs </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all possible inputs of a seed and returns them with the total balance. This is either done deterministically (by genearating all addresses until findTransactions is empty and doing getBalances), or by providing a key range to use for searching through.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>The Security level of private key / seed. </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">end</td><td>Ending key index. </td></tr>
    <tr><td class="paramname">threshold</td><td>Min balance required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad80dbd20f6efcabe5234fff81bfde6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80dbd20f6efcabe5234fff81bfde6fe">&#9670;&nbsp;</a></span>getLatestInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a> IOTA::API::Extended::getLatestInclusion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function for getNodeInfo and getInclusionStates</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hashes</td><td>The hashes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inclusion state. </dd></dl>

</div>
</div>
<a id="a05bddb596cdf2770981ab05485c9dfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bddb596cdf2770981ab05485c9dfe8">&#9670;&nbsp;</a></span>getNewAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_new_addresses.html">Responses::GetNewAddresses</a> IOTA::API::Extended::getNewAddresses </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checksum</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>total</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnAll</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a new address from a seed and returns the remainderAddress. This is either done deterministically, or by providing the index of the new remainderAddress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>Security level to be used for the private key / address. Can be 1, 2 or 3. </td></tr>
    <tr><td class="paramname">index</td><td>Key index to start search from. If the index is provided, the generation of the address is not deterministic. </td></tr>
    <tr><td class="paramname">checksum</td><td>Adds 9-tryte address checksum. </td></tr>
    <tr><td class="paramname">total</td><td>Total number of addresses to generate. </td></tr>
    <tr><td class="paramname">returnAll</td><td>If <code>true</code>, it returns all addresses which were deterministically generated (until findTransactions returns null). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of strings with the specifed number of addresses. </dd></dl>

</div>
</div>
<a id="a9a60cc7653363fb3467ed2db45d1cb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a60cc7653363fb3467ed2db45d1cb48">&#9670;&nbsp;</a></span>getTransactionsObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::getTransactionsObjects </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>trx_hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup transactions for given transaction hashes and return a list of transaction objects</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_hashes</td><td>Hashes of the transactions to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transaction objects. </dd></dl>
<p>get trytes forhashes</p>
<p>build response </p>

</div>
</div>
<a id="adc0c8ce7b3af87a350a5a47cc0b2bbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0c8ce7b3af87a350a5a47cc0b2bbb6">&#9670;&nbsp;</a></span>getTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transfers.html">Responses::GetTransfers</a> IOTA::API::Extended::getTransfers </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the transfers which are associated with a seed. The transfers are determined by either calculating deterministically which addresses were already used, or by providing a list of indexes to get the transfers from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">end</td><td>Ending key index. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bundle of transfers. </dd></dl>

</div>
</div>
<a id="ad5c237db6d1ccff2417613496a651bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c237db6d1ccff2417613496a651bc9">&#9670;&nbsp;</a></span>initiateTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::initiateTransfer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>securitySum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>inputAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>remainderAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares transfer by generating the bundle with the corresponding cosigner transactions. Does not contain signatures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">securitySum</td><td>The sum of security levels used by all co-signers. </td></tr>
    <tr><td class="paramname">inputAddress</td><td>Array of input addresses as well as the securitySum. </td></tr>
    <tr><td class="paramname">remainderAddress</td><td>Has to be generated by the cosigners before initiating the transfer, can be null if fully spent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bundle of transaction objects. </dd></dl>
<p>If message or tag is not supplied, provide it Also remove the checksum of the address if it's there</p>
<p>validate input address</p>
<p>Create a new bundle</p>
<p>Iterate over all transfers, get totalValue and prepare the signatureFragments, message and tag</p>
<p>If message longer than 2187 trytes, increase signatureMessageLength (add 2nd transaction)</p>
<p>Get total length, message / maxLength (MaxTrxMsgLength trytes)</p>
<p>copy msg</p>
<p>While there is still a message, copy it</p>
<p>Else, get single fragment with MaxTrxMsgLength of 9's trytes</p>
<p>get current timestamp in seconds</p>
<p>If no tag defined, get 27 tryte tag.</p>
<p>Pad for required TagLength tryte length</p>
<p>Add first entry to the bundle</p>
<p>Sum up total value</p>
<p>Get inputs if we are sending tokens</p>
<p>Add input as bundle entry Only a single entry, signatures will be added later</p>
<p>Return not enough balance error</p>
<p>If there is a remainder value Add extra output to send remaining funds to </p>

</div>
</div>
<a id="a489a5b783b9e585e948548b32a24fdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489a5b783b9e585e948548b32a24fdf3">&#9670;&nbsp;</a></span>replayBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_replay_bundle.html">Responses::ReplayBundle</a> IOTA::API::Extended::replayBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>transaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minWeightMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replays a transfer by doing Proof of Work again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transaction</td><td>The transaction. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth. </td></tr>
    <tr><td class="paramname">minWeightMagnitude</td><td>The minimum weight magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Analyzed Transaction objects. </dd></dl>

</div>
</div>
<a id="a0ce339b570682f2c559abf35fb57388b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce339b570682f2c559abf35fb57388b">&#9670;&nbsp;</a></span>replayTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IOTA::API::Extended::replayTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes a tail transaction hash as input, gets the bundle associated with the transaction and then replays the bundle by attaching it to the tangle. </p>

</div>
</div>
<a id="a9e2687ef56ef0340cd21be97f4d359f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2687ef56ef0340cd21be97f4d359f8">&#9670;&nbsp;</a></span>sendTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_send_transfer.html">Responses::SendTransfer</a> IOTA::API::Extended::sendTransfer </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minWeightMagnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function that basically does prepareTransfers, as well as attachToTangle and finally, it broadcasts and stores the transactions locally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth. </td></tr>
    <tr><td class="paramname">minWeightMagnitude</td><td>The minimum weight magnitude. </td></tr>
    <tr><td class="paramname">transfers</td><td>Array of transfer objects. </td></tr>
    <tr><td class="paramname">inputs</td><td>List of inputs used for funding the transfer. </td></tr>
    <tr><td class="paramname">address</td><td>If defined, this address will be used for sending the remainder value (of the inputs) to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of Transaction objects. </dd></dl>

</div>
</div>
<a id="a0e1d2f616a5fa494dfaedf4891f26fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1d2f616a5fa494dfaedf4891f26fb3">&#9670;&nbsp;</a></span>sendTrytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::sendTrytes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>trytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>minWeightMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function that gets transactions to approve, attaches to Tangle, broadcasts and stores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trytes</td><td>The trytes. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth. </td></tr>
    <tr><td class="paramname">minWeightMagnitude</td><td>The minimum weight magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions objects. </dd></dl>

</div>
</div>
<a id="a7b5c4d33e956c0d76f98aa5a7a1c6f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5c4d33e956c0d76f98aa5a7a1c6f8f">&#9670;&nbsp;</a></span>traverseBundle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> IOTA::API::Extended::traverseBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>trunkTx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basically traverse the Bundle by going down the trunkTransactions until the bundle hash of the transaction is no longer the same. In case the input transaction hash is not a tail, we return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunkTx</td><td>Hash of a trunk or a tail transaction of a bundle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled bundle corresponding to tail transaction. </dd></dl>
<p>Check for invalid hash </p>

</div>
</div>
<a id="a395484ad3ff8c373adb8c981b4f79cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395484ad3ff8c373adb8c981b4f79cd3">&#9670;&nbsp;</a></span>traverseBundle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> IOTA::API::Extended::traverseBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>trunkTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types::Trytes&#160;</td>
          <td class="paramname"><em>bundleHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;&#160;</td>
          <td class="paramname"><em>bundle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basically traverse the Bundle by going down the trunkTransactions until the bundle hash of the transaction is no longer the same. In case the input transaction hash is not a tail, we return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunkTx</td><td>Hash of a trunk or a tail transaction of a bundle. </td></tr>
    <tr><td class="paramname">bundleHash</td><td>The bundle hash. </td></tr>
    <tr><td class="paramname">bundle</td><td>Bundle to be populated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled bundle corresponding to tail transaction. </dd></dl>
<p>get trytes for transaction</p>
<p>get transaction itself </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/iota/api/<a class="el" href="extended_8hpp_source.html">extended.hpp</a></li>
<li>source/api/extended.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
